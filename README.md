# recsys-mf-ranking
Recommender System for in-depth understanding of how Candidate Generation with Ranking and Filtering works

**[PROJECT FOR STUDYING PURPOSES ONLY]**

## Overview

This Python code implements a recommender system for the MovieLens dataset with three stages. The first stage generates candidates using Matrix Factorization, the second stage is a ranking binary classification model that ingests the embedding space of user's and item features, and the third stage is a filtering part that filters movies that are already seen or manually blocked by the user. The Solution is called as Model based Recommender System with Ranking Recommender System.


## Dependencies
The code requires the following dependencies:

    NumPy: for numerical computing and Matrix Factorization
    Pandas: for data manipulation and analysis
    Scikit-learn: for evaluation metrics
    Keras: for building the binary classification model


## Dataset
The MovieLens dataset is used for this project, which contains ratings and tags of movies from the MovieLens website. The dataset can be downloaded from here https://grouplens.org/datasets/movielens/.

## Code Structure

The code is structured into three main stages:

![plot](./img/architecture.png)

### Stage 1: Candidate Generation using Matrix Factorization (Optional)

The idea behind using Candidate Generation is decreasing a number of candidates but still generate somewhat relevant content to users. 

Often this stage is implemented using collaborative filtering algorithms such as matrix factorization to generate candidates for the recommender system. 

The inclusion of this step is contingent on the number of candidates provided as input. If the dataset is small, this step may be omitted. However, if a large number of candidates is present, including this step may significantly lengthen training and inference times. This is why this step is called Candidate Generation Model.

Matrix factorization is a technique that factorizes a matrix into two lower-rank matrices. In the context of recommender systems, it is used to factorize the user-item rating matrix into user and item embeddings. The user and item embeddings are then multiplied to generate a predicted rating matrix, which can be used to generate candidate movies for the recommender system.

In the provided code we use `SVD` for explicit ratings, for implicit please refer to `SVD++`

In the provided code, `U`, `S`, and `Vt` are the three matrices obtained by performing singular value decomposition (SVD) on the user-item matrix.

SVD is a matrix factorization technique that is commonly used in recommender systems to decompose a large matrix into smaller matrices. The goal of SVD is to find a low-rank approximation of the user-item matrix that captures the most important information about the users and items.

`U` is a matrix that represents the users in a reduced dimensional space, where the columns of U are the left singular vectors. S is a diagonal matrix that contains the singular values of the user-item matrix, which represent the relative importance of the factors. Vt is a matrix that represents the items in a reduced dimensional space, where the rows of Vt are the right singular vectors.

By multiplying `U`, `S`, and `Vt`, we can reconstruct the original user-item matrix with a lower rank approximation. This allows us to predict the ratings of movies that the user has not yet seen based on the ratings of movies that the user has already seen.

For someone who is willing to deeply understand the math under SVD, please refer to this link https://machinelearningmastery.com/singular-value-decomposition-for-machine-learning/

### Stage 2: Ranking Model
let's define why we need Ranking Model if we can make predictions based only on Matrix Factorization. The main reason of using Ranking Model is that you can pass additional features apart user-item-ranking interactions that allow to achieve higher accuracy. The Ranking task can be represented as Binary Classification or as Learning-to-Rank task (list of n-th ranged items for user).

The current stage and approach uses a binary classification model to rank the candidate movies generated by matrix factorization. The binary classification model ingests the embedding space of user's and item features. The binary classification model is implemented using a fully connected neural network in Keras.

Please, Pay attention that this model is created for tutorial purposes and not based on getting the most accurate solution, So grab the architecture idea and not evaluation metrics.

### Stage 3: Filtering
This stage filters out the movies that the user has already seen or manually blocked.

## Useful Links 
High level review of different types of RecSys:
- https://thingsolver.com/introduction-to-recommender-systems/

Netflix evolved from Ratings predictions to Ranking Predictions in 2012. 
- https://towardsdatascience.com/deep-dive-into-netflixs-recommender-system-341806ae3b48
- https://netflixtechblog.com/netflix-recommendations-beyond-the-5-stars-part-1-55838468f429
- https://netflixtechblog.com/netflix-recommendations-beyond-the-5-stars-part-2-d9b96aa399f5

Twitter RecSys explained
- https://medium.com/data-achilles/twitters-recommendation-algorithm-explained-a46d357315d5

Collaborative Filtering from scratch
- https://www.geeksforgeeks.org/user-based-collaborative-filtering/

Memory-Based RecSys
- https://www.cs.carleton.edu/cs_comps/0607/recommend/recommender/memorybased.html#:~:text=Memory%2Dbased%20algorithms%20approach%20the,ratings%20for%20the%20active%20user.